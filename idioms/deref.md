# Collections are smart pointers

## Описание

Начните использовать черту `Deref`, чтобы взглянуть на коллекции как на  
интеллектуальные указатели, используя собственные и заимствованные представления данных.

## Пример

```rust,ignore
use std::ops::Deref;

struct Vec<T> {
    data: T,
    //..
}

impl<T> Deref for Vec<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //..
    }
}
```

Вектор `Vec<T>` это указатель владеющий коллекцией элементов типа `T`. А срез  
(`&[T]`) это ссылка на коллекцию элементов типа `T`. Реализация `Deref` для  
`Vec` позволяет неявное разыменовывать вектора `&Vec<T>` в срез `&[T]`.  
Большинство методов, которые, как вы могли ожидать, будут реализованы для  
`Vec`, вместо этого реализованы для срезов.

Смотрите так же `String` и `&str`.

## Что это дает?

Ключевые аспекты языка Rust это владение и заимствование. Поэтому структуры  
данных должны правильно учитывать эту семантику, как для удобства  
пользователей, так и для безопасности. А реализовав для структур владение    
собственными данными, важно реализовать и возможность заимствования, которая  
может сильно расширить гибкость нашего API.

## Преимущества

Реализуя всего один трейт, мы автоматические получаем неявную реализацию  
большинства методов для заимствованного значения.

Это дает возможность пользователям выбирать между заимствованием, или  
перехватом владения данными.

## Недостатки

Методы и черты, доступные только через разыменование, не учитываются при  
проверке границ, поэтому абстрактное программирование со структурами данных  
при использованием этого шаблона может стать сложным (см. черты `Borrow`,  
`AsRef` и т. д.).

## Обсуждение

Интеллектуальные указатели и коллекции очень похожи: интеллектуальный указатель  
указывает на один объект, тогда как коллекция указывает на множество объектов.  
С точки зрения системы типов разница между ними невелика. Коллекция владеет  
данными содержащимися в ней, и единственный способ для доступа к ним, это  
обращение через коллекцию. Та же самая ситуация и с удалением, для удаления  
единственного элемента мы все равно обращаемся к коллекции. Хорошей практикой  
будет реализовать какое то заимствованное представление для совместного  
владения коллекцией. Если же коллекция владеет своими данными, обычно полезно  
предоставить представление данных как заимствованных, чтобы на них можно было  
ссылаться несколько раз.

Большинство умных указателей (таких как `Foo<T>`) реализуют `Deref<Target=T>`.  
Однако, коллекции, как правило, разыменовываются (dereference) в какой то  
особый тип. Срезы `[T]` и `str` имеют схожую реализацию и некоторую  
дополнительную поддержку на уровне языка. Еще `Foo<T>` может реализовывать  
`Deref<Target=Bar<T>>`, где `Bar` будет типом с динамически определяемым  
размером а `&Bar<T>` заимствованное представление `Foo<T>`.

Обычно упорядоченные коллекции реализуют Index for Ranges для обеспечения  
синтаксиса срезов. Целью будет получить заимствованное представление коллекции.

## Смотрите так же

[Deref polymorphism anti-pattern](../anti_patterns/deref.md).

[Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait.Deref.html).
