# Collections are smart pointers

## Описание

Начните использовать черту `Deref`, чтобы взглянуть на коллекции как на  
интеллектуальные указатели, используя собственные и заимствованные представления данных.

## Пример

```rust,ignore
use std::ops::Deref;

struct Vec<T> {
    data: T,
    //..
}

impl<T> Deref for Vec<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //..
    }
}
```

Вектор `Vec<T>` это указатель владеющий коллекцией элементов типа `T`. А срез  
(`&[T]`) это ссылка на коллекцию элементов типа `T`. Реализация `Deref` для  
`Vec` позволяет неявное разыменовывать вектора `&Vec<T>` в срез `&[T]`.  
Большинство методов, которые, как вы могли ожидать, будут реализованы для  
`Vec`, вместо этого реализованы для срезов.

Смотрите так же `String` и `&str`.

## Что это дает?

Ключевые аспекты языка Rust это владение и заимствование. Поэтому структуры  
данных должны правильно учитывать эту семантику, как для удобства  
пользователей, так и для безопасности. А реализовав для структур владение    
собственными данными, важно реализовать и возможность заимствования, которая  
может сильно расширить гибкость нашего API.

## Преимущества

Можно реализовать большинство методов для заимствованного значения, неявно  
реализовывая их и для предствления когда мы владеем данными.

Это дает возможность пользователям выбирать между заимствованием, или  
перехватом владения данными.

## Недостатки

Методы и черты, доступные только через разыменование, не учитываются при  
проверке границ, поэтому универсальное программирование со структурами данных  
при использованием этого шаблона может стать сложным (см. черты `Borrow`,  
`AsRef` и т. д.).

## Обсуждение

Интеллектуальные указатели и коллекции очень похожи: интеллектуальный указатель  
указывает на один объект, тогда как коллекция указывает на множество объектов.  
С точки зрения системы типов разница между ними невелика. Коллекция является  
хозяном своих данных, поэтому единственным способом получить доступ к каждому  
элементу данных - будет обратиться к каждому элементу данных. Тоже самое будет и  
при удалении элемента. Поэтому будет очень полезно иметь хотя бы одно  
представление коллекции для возможности заимствования. Даже в случаях  
совместного владения может быть уместно иметь API для обращения по ссылке.

Большинство умных указателей (таких как `Foo<T>`) реализуют `Deref<Target=T>`.  
Однако, коллекции как правила разыменовываются (dereference) на какой то  
особый тип. Указатели `[T]` и `str` имеют одинаковую поддержу языка, но в общем случае это не обязательно.
`Foo<T>` может реализовывать `Deref<Target=Bar<T>>` где `Bar` будет типом с  
динамически определяемым размером и иметь представление для использования  
`Foo<T>` как `&Bar<T>`.

Commonly, ordered collections will implement `Index` for `Range`s to provide
slicing syntax. The target will be the borrowed view.

## See also

[Deref polymorphism anti-pattern](../anti_patterns/deref.md).

[Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait.Deref.html).
