# On-Stack Dynamic Dispatch

## Описание

В Rust не смотря на жесткую типизацию, мы можем инициализировать значение  
динамически. Но для этого нам надо указать какой то общий типаж (trait) который  
будут иметь все потенциальные варианты возращаемого значения. А так же иметь  
несколько переменных для того, что бы привязвать объекты с разными типами.  
В примере ниже мы используем отложенную инициализацию, которая нам позволит  
продлевать время жизни по мере необходимости:

## Пример

```rust
use std::io;
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let arg = "-";
    
    // Эти значения должны жить дольше чем переменная readable, поэтому мы
    // должны объявить их первыми:
    let (mut stdin_read, mut file_read);
    
    // Для того что бы получить динамическую инициализацию, нам нужно сначала
    // задать переменной readable тип (в текущем примере это трейт).
    let readable: &mut dyn io::Read = if arg == "-" {
        stdin_read = io::stdin();
        &mut stdin_read
    } else {
        file_read = fs::File::open(arg)?;
        &mut file_read
    };
// Теперь можно читать из `readable`.
 Ok(())
}
```

## Зачем это нужно?

Так как Rust по умолчанию мономорфизирует код, компилятор будет создавать новую  
копию для каждого выведенного типа и оптимизировать по отдельности. Хотя это  
приводит к очень большому приросту производительности (по сравнению с полиморф-  
ными языками), это так же может приводить к тому, что код в итоге получается  
"раздутым", а время комиляции неуклонно растет.

К счастью, Rust так же позволяет нам использовать и динамическую передачу, но  
тогда мы должны писать соответствующий код для кормилятора.

## Преимущества

Например нам не нужно алоцировать память в heap. Нам так же не нужно инициализи-  
ровать то что мы не будем использовать позже. Что позволит компилятору пропустить  
мономорфизацию не нужного нам кода. В результате в нашем примере выше, ни `File`  
ни `Stdin` не будут мономорфизироваться.

## Недостатки

Код в становится более объемным и пространным чем основанный на `Box`:

```rust
use std::io;
use std::fs;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Нам все еще нужно задавать тип.
    let readable: Box<dyn io::Read> = if arg == "-" {
        Box::new(io::stdin())
    } else {
        Box::new(fs::File::open(arg)?)
    };
// Теперь можно читать из `readable`.
}
```

## Давайте обсудим

Тот кто начинает изучать Rust, первым делом сталкивается с тем, что все переменные   
должны быть инициализированы *перед использованием*, поэтому могут легко упустить  
из виду тот факт, что инициализацию для *неиспользуемых* переменных можно опустить.  
Rust в свою очередь будет усердно работать, чтобы все работало нормально, и только  
инициализированные значения отбрасывались при выходе из области видимости.

Пример соответствует всем ограничениям, которые накладывает на нас Rust:

* Все переменные инициализируются перед их использованием (в данном случае с помощью  
заимствования).
* Каждая переменная хранит только один конкретный тип. В нашем примере, `stdin`  
имеет тип `Stdin`, `file` имеет тип `File`, а `readable` относится к типу `&mut dyn  
Read`.
* Каждое заимствованное значение переживает все заимствованные из него ссылки.

## Смотрите так же

* [Finalisation in destructors](dtor-finally.md) и 
[RAII guards](../patterns/behavioural/RAII.md) как извлекать выгоду из жесткого  
контроля над временем жизни.
* Алгебраличиские типы `Option<&T>` содержащие изменяемую (mutable) ссылку,  
можно инициализировать напрямую как `Option<T>` и использовать метод [`.as_ref()`]  
что бы получать опциональную ссылку.

[`.as_ref()`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref
