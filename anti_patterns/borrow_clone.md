# Clone to satisfy the borrow checker

## Описание

В компиляторе Rust заложеное одно очень полезное свойство, это инспектор  
заимствований (*borrow checker*). Инспектор зависимостей нужен для того, что бы   
при разработке на Rust предотвратить использование небезопасного кода. Это  
работает с помощью проверки, что существует только одна *mutable* ссылка,  
а все множество *immutable* ссылок указывают на все еще существующий объект.  
Но некоторые разработчики пишут код который нарушает работу инспектора  
заимствований, они исправляют ошибки компиляции клонированием переменной.

## Пример

```rust
fn main() {
    // Объявляем переменную.
    let mut x = 5;
    
    // Здесь мы хотим заимствовать `x` -- но вместо этого клонируем.
    let y = &mut (x.clone());
    
    // Выполняем некие операции для того что бы предотвратить оптимизации  
    // компилятора (иначе комилятор схлопнет два одинаковых значения в одно).
    *y += 1;
    
    // Если бы мы не использовали x.clone() чуть раннее, наш пример бы не  
    // смог скомпилироваться, так как x был заимствован y.
    // Но спасибо x.clone(), в результате которого заимствование x не 
    // происходит и println спокойно выполняется.
    println!("{}", x);
}
```

## Что мы получаем?

Для новичков может выглядеть очень привлекательным такое решение проблем  
заимствований. Но надо понимать, что это несет за собой серьезные последствия.  
Используя `.clone()` мы создаем копию данных. А любые изменения между  
клонированными переменными происходят для каждой по отдельности.

В Rust так же есть специально разработанный для интелектуальной обработки  
клонов -- `Rc<T>`. Но он используется только в особых случаях и создан для  
того что бы держать в себе только одну копию данных, а по `.clone()` передавать  
новую ссылку.

Еще есть `Arc<T>` для предоставление совместного владения (*ownership*)  
значениме типа T размещенным в куче (*heap*). Вызов `.clone()` на `Arc` создает  
еще один инстанс `Arc` указывающий на ту же самую область памяти в куче, что и  
исходный `Arc`, при этом увеличивая счетчик ссылок на один.

В общем, клонирование должно быть осознанным, с полным пониманием последствий.  
Если клон используется для устранения ошибки инспектора заимствований, это  
явный признак того, что скорее всего используется данный (*borrow_clone*)  
антишаблон.

Если подытожить выше сказанное, то не смотря на то что `.clone()` может быть  
индикатором неправильно использования заимствования, **иногда неэффектиный  
код может быть необходим**. Например в таких случаях как:

- разработчик все еще новичок
- код не требует экономичного использования памяти и скорости выполнения  
  (например в при прототипировании или на хакатонах)
- особый случай, когда оптимизация и производительность ставится в угол по  
  отношению к читаемости и обслуживаемости кода

Но помните, что если вы раздумываете над тем разобраться в ошибке  
заимствования, или просто использовать `.clone()`, то возможно стоит еще раз  
перечитать эту статью и главу [Rust Book's chapter on Ownership](https://doc.rust-lang.org/book/ownership.html).

Так же не забывайте запускать в своем проекте `cargo clippy`. Он поможет вам  
найти случаи когда `.clone()` не нужен, например [1](https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone),
[2](https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy),
[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone) или [4](https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref).

## Смотрите так же

- [`mem::{take(_), replace(_)}` to keep owned values in changed enums](../idioms/mem-replace.md)
- [`Rc<T>` documentation, which handles .clone() intelligently](http://doc.rust-lang.org/std/rc/)
- [`Arc<T>` documentation, a thread-safe reference-counting pointer](https://doc.rust-lang.org/std/sync/struct.Arc.html)
- [Tricks with ownership in Rust](https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)
