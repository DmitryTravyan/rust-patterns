# `Deref` polymorphism

## Описание

Rust довольно часто упоминается как язык пригодный для объектно  
ориентированного программирования. Поэтому новички изучая возможности  
языка могут попытаться реализовать один из ключевых столпов ООП наследование.  
Но в Rust считается плохой практикой использовать трейт `Deref` для имитации  
наследования между стуктурами, и получения таким образом возможности  
переиспользования методов.

## Пример

Иногда нам хочется повторить какой ни будь популярный щаблон, например  
наследование которое есть в таком объектно ориентированном языке как Java:

```java
class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
```

Для того что бы сделать что то похожее мы можем использовать анти-шаблон  
имитирующий полиморфизм - deref:

```rust
use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&self) -> &Foo {
        &self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
```

В Rust нет наследования классов. И что бы сымитировать его, мы используем  
композицию передавая инстанс структуры `Foo` в `Bar`. Так мы хотим добиться  
схожей с Java структурры памяти, ведь в Rust комипятор заинлайнит `f`.
> Возможно для уверености повторения придется использовать `#[repr(C)]`

Теперь, чтобы мы могли вызвать метод из родительского класса, мы реализуем  
`Deref` для `Bar` с `Foo` в качестве цели (возвращаем поле `Foo`). Это  
означает, что когда мы разыменовываем `Bar` (например, используя `*`), мы  
получим `Foo`. Это именно то, что мы обычно привыкли видеть в Rust. Как правило  
разыменование дает нам по ссылке типа `T` владением типом `T`, здесь же мы   
получаем совершенно не связанный тип. Однако из-за того, что оператор `.`  
разыменовывает неявно, мы получаем доступ сразу, и к методам `Foo`, и к методам  
`Bar`.

## Преимущества

Вы получаете вполне рабочий шаблон:

```rust,ignore
impl Bar {
    fn m(&self) {
        self.f.m()
    }
}
```

## Недостатки

Наиболее важной проблемой является то, что мы получаем совершенно нетипичную  
ситуацию для строго типизированного Rust. Программисты унаследовавшие наш код,  
будут очень удивлены когда столкнутся с тем что мы написали. Все потому что  
злоупотребляя трейтом `Deref` вместо того, что бы использовать его по  
назначению (как задокументировано), мы делаем код совершенно не прозрачным и  
не явным.

Этот антишаблон не создает некие подтипы `Foo` и `Bar`, как это бывает при  
наследовании реализованном языками Java и C++. Более того, трейты реализуемые  
для родительской структуры `Foo` не будут автоматически реализовываться и для  
`Bar`. Все потому, что проверка границ и абстрактное программирование в Rust  
на это не расчитаны.

Использование этого шаблона дает несколько отличную от большинства  
объектно-ориентированных языков семантику в отношении `self`. Обычно это  
ссылка на объект самой структуры, но в этом шаблоне это будет вложенный  
«класс», в котором определен метод `m`.

Наконец, этот шаблон поддерживает только одиночное наследование и не имеет  
понятия об интерфейсах, а так же конфиденциальности на основе классов, или  
других функциях связанных с наследованием. В результате, программист  
расчитывающий на наследование "как в Java" будет сбит с толку.

## Обсуждение

Конкретной "лучшей альтернитивы" данному патерну нет. В зависимости от ситуации  
может быть выгоднее заново реализовать нужные нам методы для структуры которая  
должна быть дочерней. Или написать методы которые будут инициализировать `Foo`  
вручную. У нас есть планы по добавлению в Rust механизма наследования, но  
пройдет еще не мало времени прежде чем это достигнет стабильной версии.  
Смотрите тут [blog](http://aturon.github.io/blog/2015/09/18/reuse/)
[posts](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/)
и тут [RFC issue](https://github.com/rust-lang/rfcs/issues/349).

Трейт `Deref` спроектирован для реализации кастомных типов указателей.  
Предполагается, что он будет получать указатель типа `T` на данные типа `T`,  
а не конвертировать один тип в другой. Что к сожалению не закрепляется  
сигнатурой типа.

Rust пытается найти баланс между явными и неявными механизмами, отдавая  
предпочтение более очевидным преобразованиям. Автоматическое разыменование в  
операторе точки - это тот случай, когда предпочтение отдается удобству  
использования, а не явной реализации трейта. Но намеренье авторов состоит в  
том, что такое такой механизм лишь косвенно путает нас, а не закладывает  
неявное преобразованием между произвольными типами.

## Смотрите так же

- [Collections are smart pointers idiom](../idioms/deref.md).
- Крейты (crates), для уменьшения количества шаблонного кода [delegate](https://crates.io/crates/delegate)
  или [ambassador](https://crates.io/crates/ambassador)
- [Documentation for `Deref` trait](https://doc.rust-lang.org/std/ops/trait.Deref.html).
