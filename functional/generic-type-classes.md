# Generics as Type Classes

## Описание

В Rust система типов была спроектирована так, что бы быть более похожей на 
функциональную (как в Haskell), чем на императивную (как в Java и C++).
Что в результате привело к тому, что большинство решаемых нами проблем 
"программирования" превратились в проблемы "статической типизации". Для многих
это может быть тем, что послужит "решающим аргументом" при выборе именно 
функционального языка. Так как Rust гарантирует проверку типов еще на этапе
компиляции.

Одной из ключевых частей дизайна Rust является работа с абстрактными (generic)
типами. Например, в C++ и Java абстрактные типы представляют собой конструкты
с определенной метаинформацией для компилятора. Объекты `vector<int>` и 
`vector<char>` в C++ это просто две копии одного и того же стандартного кода
типа `vector` (более известного как `template`), имеющего две разные
сигнатуры.

В то же время в Rust, абстрактные (generic) типы создают то, что в функциональных
языках называют "ограничением типажа" (type class constraint), и позволяют
каждому новому параметру заполняемому разработчиком *фактически изменять тип*.
Другими словами `Vec<usize>` и `Vec<char>` *это два разных типа*, которые 
распознаются системой типов не как копии с разными сигнатурами, а именно 
как отдельные типы.

В программировании это называется **моноформизацией** (monomorphization), и 
означает что типы могут создаваться из **полиморфного** (polymorphic) кода. 
Это особое поведение требует для создания абстрактных параметров специального 
`impl` блока. И приводит к тому, что указывая возможные типы значений, которые 
может принимать реализация абстрактного типа. Мы говорим компилятору, что для
каждой конкретной реализации нужно создать отдельную копию на основе конкретных
значений.

В тоже время в объектно ориентированных языках, классы могут наследовать поведение 
своих родителей. Это позволяет расширять с помощью новых черт не только дочерний тип
но и создавать некую абстракцию.

Ближайшим эквивалентом является полиморфиз реализуемый во временя выполнения программы
написанной на Javascript и Python, когда с помощью конструкторов новые методы могут 
добавляться принудительно прямо во время выполнения. Однако в Rust новые методы
будут проверяться по типу еще на этапе компиляции, потому что подмножество реализаций
абстрактного метода определяется статически. И для каждой реализации копиятором 
создается свой статический набор методов.

## Пример

Предположим, вы разрабатываете сервер который будет хранить данные производимые
несколькими лабораторными машинами. Из-за того что лаборатоные машины могут работать
на разном програмном обеспечении, нам нужно поддерждать два разных протокола.
BOOTP (для загрузки через сеть по PXE), и NFS (для монтирования удаленного ханилища).

Ваша цель, написать одну единственную программу на Rust, которая будет поддерживать
оба типа лабораторных машин. У этой программы будут обработчики сразу двух
протоколов и она будет получать оба типа запросов. В результате у администратора
должна быть возноможность настраивать оба типа хранения данных и настройки 
безопасности из единого интерфейса по схожей схеме.

Запросы от лабораторных машин будут содержать одну и ту же информацию с
одинаковой структурой данных вне зависимости от протокола, типа аутетификации
и имени файла. И в виде простейшей реализации выглядела бы так:

```rust
enum AuthInfo {
    Nfs(crate::nfs::AuthInfo),
    Bootp(crate::bootp::AuthInfo),
}
struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
}
```

В таком виде это будет работать просто отлично. Но допустим вы бы хотел поддержать
добавление *специфичных для конкретного протокола* метаданных. Например для NFS
вы бы хотели определить точку монтирования для поддержи дополнительной правил
безопасности сохраняемых данных.

Текущая структура FileDownloadRequest позволяется оставить выбора протокола
до момента времени выполнения нашего приложения. Это означает, что любой 
метод применимый только к одному из протоколов должен иметь набор проверок
на то, что он не будет применен к другому во время выполнения.

Вот так будет выгляеть получение точки монтирования для файловой системы NFS:

```rust
struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
    mount_point: Option<PathBuf>,
}
impl FileDownloadRequest {
    // ... другие общие методы ...
    /// Этот метод по запросу получает точку монтирования NFS. Но если это не NFS
    /// то метод возвращает None.
    pub fn mount_point(&self) -> Option<&Path> {
        self.mount_point.as_ref()
    }
}
```

Такой подход приводит к тому, что при каждом вызыве `mount_point()` теперь надо провероять
не возвращает ли этот метод `None` и конечно же писать код который будет обрабатывать None.
В Rust это правильный код, даже если мы можем быть уверены, что в текущей ситуации мы будем
запрашивать только NFS, и никогда Bootp.

Конечно оптимальнее было бы вызывать ошибку еще во время компиляции если
типы запросов перепутались. Так как при таком использовании мы бы знали о типах
запросов еще на этапе написания программы. Ведь в конце концов в любой
момент написания кода мы должны знать какие конкретно функции библиотеки нам 
будут нужны. Будь то NFS или BOOTP запрос.

В Rust, это действительно возможно. Решение состоит в том что бы добавить 
*абстрактный тип* что бы разделить API.

Вот как это будет выглядеть:

```rust
use std::path::{Path, PathBuf};
mod nfs {
    #[derive(Clone)]
    pub(crate) struct AuthInfo(String); // NFS управление сеансом опущено
}
mod bootp {
    pub(crate) struct AuthInfo(); // для BOOTP аутентификация не нужна
}
// приватный модель, что бы посторонние пользователи библиотеки не изобретали свои протоколы!
mod proto_trait {
    use std::path::{Path, PathBuf};
    use super::{bootp, nfs};
    pub(crate) trait ProtoKind {
        type AuthInfo;
        fn auth_info(&self) -> Self::AuthInfo;
    }
    pub struct Nfs {
        auth: nfs::AuthInfo,
        mount_point: PathBuf,
    }
    impl Nfs {
        pub(crate) fn mount_point(&self) -> &Path {
            &self.mount_point
        }
    }
    impl ProtoKind for Nfs {
        type AuthInfo = nfs::AuthInfo;
        fn auth_info(&self) -> Self::AuthInfo {
            self.auth.clone()
        }
    }
    pub struct Bootp(); // никаких дополнительных метаданных
    impl ProtoKind for Bootp {
        type AuthInfo = bootp::AuthInfo;
        fn auth_info(&self) -> Self::AuthInfo {
            bootp::AuthInfo()
        }
    }
}

// используем train только как внутренний для того что бы предотвратить сторонние impls
use proto_trait::ProtoKind;
pub use proto_trait::{Nfs, Bootp}; // реэкспортируем структуры с уже имеющимися impls
struct FileDownloadRequest<P: ProtoKind> {
    file_name: PathBuf,
    protocol: P,
}

// все основные чати API переносим внутрь абстрактоного impl блока
impl<P: ProtoKind> FileDownloadRequest<P> {
    fn file_path(&self) -> &Path {
        &self.file_name
    }
    fn auth_info(&self) -> P::AuthInfo {
        self.protocol.auth_info()
    }
}

// все специфичные для конкретного протокола методы переностим внутрь собственного impl
impl FileDownloadRequest<Nfs> {
    fn mount_point(&self) -> &Path {
        self.protocol.mount_point()
    }
}
fn main() {
    // ваш код будет здесь
}
```

При таком подходе, если разработчик допустит ошибку и использует неверный тип;

```rust,ignore
fn main() {
    let mut socket = crate::bootp::listen()?;
    while let Some(request) = socket.next_request()? {
        match request.mount_point().as_ref()
            "/secure" => socket.send("Доступ запрещен"),
            _ => {} // продолжать с кодом написанным здесь :)...
        }
        // Остальной код тут
    }
}
```

Такой код вызовет ошибку, так как `FileDownloadRequest<Bootp>` не имеет реализации
`mount_point()`, так как только у типа `FileDownloadRequest<Nfs>` есть такой метод.
Так как раннее мы написали реализацию `mount_point()` только для NFS, но не для
BOOTP.

## Преимущества

Во первых, это позволяет исключить дублирование кода и умешить его общее 
количество (что упростит читаемость и обслуживание). Делая поля уникальные
для типа не общим, их достаточно реализовать лишь единожды. 

Во вторых это упрощает чтение кода, так как блоки `impl` разбиваются на части 
уникальные для каждого типа. В то время как общие для всех типов методы 
собираются в одно единственном `impl`.

Оба этих фактора означают, что код становится лучше органихован и лучше структурирован.

## Недостатки

Из-за моноформизации это увеличивает размер исполняемого (binary) файла. В текущий
момент компилятор статически генерирует методы для каждого типа совпадающего по
сигнатурам с абстрактным. Но есть надежда, что со вренем это будет исправлено.

## Альтернативы

* Если тип требует "раздельного API" во время конструирования или частичной
иницализации, лучше рассмотрите
[Builder Pattern](../patterns/creational/builder.md).

* Если API не меняется в зависимости от типа, а изменяется только поведение, тогда
лучше использовать паттерн [Strategy Pattern](../patterns/behavioural/strategy.md).

## Так же обратите внимание

Этот паттерн используется в стандратной библиотеке:

* `Vec<u8>` может быть приведен в String, в отличии от любого другого типа `Vec<T>`.[^1]
* В тоже время эти типы можно преобразовать в binary heap если они реализуют черту
`Ord`.[^2]
* Метода `to_string` ограничен только типажом `Cow` и только для типа `str`.[^3]

Он также используется несколькими популярными crates для обеспечения более гибкого API:

* Экосистема `embedded-hal` используемая для embedded устройств широко использует этот
  шаблон. Например, это позволяет статически проверять конфигурацию регистров 
  устройства используемых для embedded pins. Когда режим pin меняется, он возвращает
  `Pin<MODE>` структуру, которая уже имеет абстрактные методы которые работаю по разному
  в зависимости от реального типа `Pin`. [^4]

* Web фреймворк `hyper` предоставляет по настроящему богатый набор APIs для раздичных
  типов подключений. Клиенты с разлиными типами connectors могут в результате иметь
  различные реализации типажей в то время как их все еще можно будет обрабатывать с
  помощью общего набора осноных методов. [^5]

* Паттерн "type state" осованный на получении и потере объектом API от внутреннего состояния
  реализован в Rust по схожей концепции, но немного другой теххнике. [^6]

[^1]: Смотрите: [impl From\<CString\> for Vec\<u8\>](
https://doc.rust-lang.org/stable/src/std/ffi/c_str.rs.html#799-801)

[^2]: Смотрите: [impl\<T\> From\<Vec\<T, Global\>\> for BinaryHeap\<T\>](
https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs.html#1345-1354)

[^3]: Смотрите: [impl\<'_\> ToString for Cow\<'_, str>](
https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2235-2240)

[^4]: Пример:
[https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html](
https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html)

[^5]: Смотрите:
[https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](
https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html)

[^6]: Смотрите:
[The Case for the Type State Pattern](
https://web.archive.org/web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-pattern-itself/)
и
[Rusty Typestate Series (an extensive thesis)](
https://web.archive.org/web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index)
